Zealous Black Grasshopper

High

# Generation of OrderId is not completely unique which can cause overwriting details of previous orders

### Summary

While creating a `Bracket` order every order has a unique and randomly generated `orderId`. This `orderId` is generated by the following function:
```solidity
    ///@notice generate a random and unique order id
    function generateOrderId(address sender) external view override returns (uint96) {
            //@audit Hash of senders address and block.timestamp is taken to generate orderId
            uint256 hashedValue = uint256(
            keccak256(abi.encodePacked(sender, block.timestamp))
        );
        return uint96(hashedValue);
    }
```
The parameters used to generate `orderId` might not be sufficient to give a unique id as the only parameter that is changing (for a particular user) is `block.timestamp` which will be same if user is making multiple orders in single block which would eventually lead to overwriting his previous orders and end up with having only one open order. Due to this the tokens that user have sent [(mentioned in code below)](https://github.com/sherlock-audit/2024-11-oku/blob/main/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol#L384) for creating previous bracket orders will get compromised.
```solidity
    //Bracket::_initializeOrder()
    //....
    procureTokens(tokenIn, amountIn, msg.sender, permit, permitPayload);
    //....
```
Generation of `orderId` can also get affected by the miners, where miners can manipulate `block.timestamp` to grief a particular user in small time frame. 

### Root Cause

In [AutomationMarket::line92](https://github.com/sherlock-audit/2024-11-oku/blob/main/oku-custom-order-types/contracts/automatedTrigger/AutomationMaster.sol#L92) generation of `orderId` in not completely random and unique. 

### External pre-conditions

User will have to place multiple orders in same block 
OR 
Block miner is malicious and is trying to grief a user by adjusting `block.timestamp` 

### Impact

An honest user will loose all the tokens that he sent to place all previous orders.

### Mitigation

Using one more parameter like `nonce` will be effective to generate a random and unique `orderId` where nonce can be increased after every new order that is created OR creating a mapping like:
```solidity
    mapping(address => uint256) userNonce;
```
Where nonce will be tracked for each user and increased for every order user place.