Ripe Orange Tadpole

Medium

# Orders will be overwritten in a multicall

### Summary

The finding demonstrates how usage of the multicall functionality and trying to create multiple orders in one transaction would lead to the orders being overwritten.

### Root Cause

The root cause lies in the fact that orders are generated with only 2 parameters: `sender` and `block.timestamp`. So if a sender of the tx decides to use a multicall to generate multiple orders in one transaction, one order will overwrite the other.

### Internal pre-conditions

_No response_

### External pre-conditions

_No response_

### Attack Path

Users will try to use multicall and generate multiple orders in one transaction. Due to the way of how orders are generated, only the last order will be created and the previous orders will overwrite each other.

### Impact

Users would not be able to create multiple orders in the same transaction.

### PoC

Let's take a look at the following implementation:

https://github.com/sherlock-audit/2024-11-oku/blob/main/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol#L475-478
```solidity
   //generate random but unique order id if there is not an existing orderId from a stop limit order
        if (existingOrderId == 0) {
            existingOrderId = MASTER.generateOrderId(msg.sender);
        }
```

https://github.com/sherlock-audit/2024-11-oku/blob/main/oku-custom-order-types/contracts/automatedTrigger/AutomationMaster.sol#L89-95
```solidity
  ///@notice generate a random and unique order id
    function generateOrderId(address sender) external view override returns (uint96) {
        uint256 hashedValue = uint256(
            keccak256(abi.encodePacked(sender, block.timestamp))
        );
        return uint96(hashedValue);
    }
```

As you can see, if a user tries to create multiple new orders in one transaction, he would have to specify `existingOrderId` as 0 and the order will be generated by using `msg.sender` and `block.timestamp` values. However, in a multicall `msg.sender` would be the same and `block.timestamp` would also be the same for every order so the orders would be simply overwritten here:


https://github.com/sherlock-audit/2024-11-oku/blob/main/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol#L480-493
```solidity
 //construct order
        orders[existingOrderId] = Order({
            orderId: existingOrderId,
            takeProfit: takeProfit,
            stopPrice: stopPrice,
            amountIn: amountIn,
            tokenIn: tokenIn,
            tokenOut: tokenOut,
            recipient: recipient,
            takeProfitSlippage: takeProfitSlippage,
            feeBips: feeBips,
            stopSlippage: stopSlippage,
            direction: MASTER.getExchangeRate(tokenIn, tokenOut) > takeProfit //exchangeRate in/out > takeProfit
        });
```

### Mitigation

Use some additional parameters like salt to generate order ids.