Slow Rose Puppy

High

# Order Id Generation will Override Existing Order in the Same Block

### Summary

Generating order ids by hashing the sender and the current block.timestamp will cause the same orderId for orders by the same user in the same block. This overrides the orders mapping effectively "deleting" user's orders and stealing their deposited funds. 

### Root Cause

In AutomationMaster:generateOrderId:90-95 the order id is generated by hashing the sender and the block.timestamp. 

https://github.com/sherlock-audit/2024-11-oku/blob/ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/AutomationMaster.sol#L90C3-L96C1

Since block.timestamp is constant inside a block, users with multiple createOrder calls put into the same block by the sequencer will have their orders override each other, while still paying for both orders. The orders do not even have to be identical for this to occur. 

### Internal pre-conditions

_No response_

### External pre-conditions

1. A user or smart contract submits multiple createOrder calls to OracleLess.sol, StopLimit.sol, or Bracket.sol in a relatively short time period.

### Attack Path

_No response_

### Impact

User's latest executing order will override their previous orders, with no refund for the earlier orders which are now unaccounted for. This results in a 100% loss of user funds for orders executed prior to the last executing order in a block.

### PoC

This uses an anvil node forking arbitrum main-net.

```solidity
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import {Test, console2 as console} from "lib/forge-std/src/Test.sol";
import {Gas} from "test/Gas.sol";
import "src/automatedTrigger/IAutomation.sol";
import {OracleLess} from "src/automatedTrigger/OracleLess.sol";
import {AutomationMaster} from "src/automatedTrigger/AutomationMaster.sol";
import {Bracket} from "src/automatedTrigger/Bracket.sol";
import {StopLimit} from "src/automatedTrigger/StopLimit.sol";
import {IPermit2} from "src/interfaces/uniswapV3/IPermit2.sol";
import {IERC20} from "src/interfaces/openzeppelin/IERC20.sol";

contract Setup is Test, Gas {
    AutomationMaster internal automation;
    OracleLess internal oracleLess;
    Bracket internal bracket;
    StopLimit internal stopLimit;

    IPermit2 internal permit;

    IERC20 internal weth = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);
    IERC20 internal usdc = IERC20(0xaf88d065e77c8cC2239327C5EDb3A432268e5831);

    address internal _alice = address(0x1111);
    address internal _bob = address(0x2222);

    address internal _admin = address(0x12345);

    address internal _wethWhale = 0xC6962004f452bE9203591991D15f6b388e09E8D0;
    address internal _usdcWhale = 0x70d95587d40A2caf56bd97485aB3Eec10Bee6336;

    function setUp() public virtual {
        uint256 forkId = vm.createSelectFork("http:127.0.0.1:8545");

        vm.startPrank(_admin);
        automation = new AutomationMaster();
        permit = IPermit2(0x000000000022D473030F116dDEE9F6B43aC78BA3);

        bracket = new Bracket(IAutomationMaster(address(automation)), permit);
        stopLimit = new StopLimit(
            IAutomationMaster(address(automation)),
            IBracket(address(bracket)),
            permit
        );
        oracleLess = new OracleLess(automation, permit);

        vm.stopPrank();
        vm.startPrank(_wethWhale);
        weth.transfer(_alice, 10 ether);
        weth.transfer(_bob, 10 ether);
        vm.stopPrank();

        vm.startPrank(_usdcWhale);
        weth.transfer(_alice, 10000e6);
        weth.transfer(_bob, 10000e6);
        vm.stopPrank();
    }

    function testSameOrderId() public {
        vm.startPrank(_alice);
        weth.approve(address(oracleLess), 2 ether);

        uint256 firstOrderId = oracleLess.createOrder(
            weth,
            usdc,
            1 ether,
            4000e6,
            _alice,
            300,
            false,
            bytes(abi.encode(""))
        );

        uint256 secondOrderId = oracleLess.createOrder(
            weth,
            usdc,
            0.5 ether,
            2000e6,
            _alice,
            100,
            false,
            bytes(abi.encode(""))
        );
        vm.stopPrank();

        assertEq(firstOrderId, secondOrderId, "Failed SameOrderId");

        console.log("First Order Id  : ", firstOrderId);
        console.log("Second Order Id : ", secondOrderId);
    }
}

```

```solidity
Ran 1 test for test/Setup.t.sol:Setup
[PASS] testSameOrderId() (gas: 266417)
Logs:
  First Order Id  :  44856353444247396937644027416
  Second Order Id :  44856353444247396937644027416

```

### Mitigation

Add mapping to use a nonce value when generating new orderIds. 