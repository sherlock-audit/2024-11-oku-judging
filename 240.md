Smooth Ultraviolet Turkey

High

# OrderId can be easily overwritten which can be exploited to drain contract

### Summary

The `OrderId` is generated by calculating the hash of sender and block.timestamp. Which will be same for all the transactions of a user in a single block. The order creation flow in `Bracket.sol`, `StopLimit.sol` & `OracleLess.sol` overwrites the existing order with new values if the OrderId is same but creates a duplicate orderId entry in `pendingOrderIds`. Which means now the last order will be executed multiple times. An attacker can create 9 minimum values orders and 1 bigger last order. When the execution will happen the `performUpkeep()` will execute last order 10 times. Hence draining the contract. The attacker can replay this attack any number of times.

https://github.com/sherlock-audit/2024-11-oku/blob/main/oku-custom-order-types/contracts/automatedTrigger/AutomationMaster.sol#L90C1-L95C6
```solidity
    function generateOrderId(address sender) external view override returns (uint96) {
        uint256 hashedValue = uint256(
=>          keccak256(abi.encodePacked(sender, block.timestamp))
        );
        return uint96(hashedValue);
    }
```

### Root Cause

In all the below files the order with same orderId is overwritten with new data.

1. https://github.com/sherlock-audit/2024-11-oku/blob/main/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol#L476C1-L496C47
2. https://github.com/sherlock-audit/2024-11-oku/blob/main/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol#L52C1-L64C39
3. https://github.com/sherlock-audit/2024-11-oku/blob/main/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol#L334C1-L353C47

### Internal pre-conditions

_No response_

### External pre-conditions

_No response_

### Attack Path

1. Alice writes a contract which creates 10 order in a single transaction. It create 9 orders to swap 1 USDC and create 10th order to swap 100 USDC.
2. Now, because all these transactions are gonna go in a single block. The generated OrderId will be same. So, all these orders will be replaced by the last order details. Which will be to swap 100 USDC.
3. The `pendingOrderIds` mapping will store same orderId 10 times.
4. Now, when these orders are executed, Alice's order gets executed 10 times and get 100 * 10 = 1000 USDC. But 9 of her orders were 1 USDC. So she paid 109 USDC and got 1000 USDC back.

### Impact

The attacker can drain the contract by creating multiple orders and replacing the order data with the last one and executing the last order multiple times.

### PoC

_No response_

### Mitigation

Create a nonce mapping per user. Increment this nonce and use this nonce in hash calculation of OrderId. This will ensure that a new orderId is created every single time.
```diff
+++ mapping(address => uint256) userNonce;

    function generateOrderId(address sender) external view override returns (uint96) {

---     uint256 hashedValue = uint256(
---       keccak256(abi.encodePacked(sender, block.timestamp))
---     );

+++     uint256 hashedValue = uint256(
+++       keccak256(abi.encodePacked(sender, userNonce[sender], block.timestamp))
+++     );

+++     userNonce[sender] +=1;

        return uint96(hashedValue);
    }

```